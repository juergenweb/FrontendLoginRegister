<?php
    declare(strict_types=1);

    /*
     * Comments Fieldtype for storing user comments for a page
     * This comments field is especially designed to work with the FrontendForms module
     *
     * Created by Jürgen K.
     * https://github.com/juergenweb
     * File name: FieldtypeFrontendComments.module
     * Created: 23.06.2023
     */

    namespace ProcessWire;

    use DateInterval;
    use DateTime;
    use Exception;
    use FrontendComments\CommentArray;
    use FrontendComments\Comment;
    use FrontendComments\configValues;
    use FrontendComments\Notifications;
    use PDO;

    // include all necessary files
    $dirname = dirname(__FILE__);
    require_once($dirname . "/traits/configValues.php");
    require_once($dirname . "/CommentArray.php");
    require_once($dirname . "/CommentForm.php");
    require_once($dirname . "/Comments.php");
    require_once($dirname . "/Comment.php");
    require_once($dirname . "/Notifications.php");
    require_once($dirname . "/InputfieldFrontendComments.php");

    class FieldtypeFrontendComments extends FieldtypeMulti
    {

        use configValues;

        const moderateNone = 0; // no moderation - all comments will be published immediately
        const moderateAll = 1; // all comments need to be approved
        const moderateNew = 2; // only new comments need to be approved
        protected FrontendForms $frontendForms;

        // configuration values
        public static string $primaryBg = '#2196F3'; // primary color
        public static string $secondaryBg = '#323a45'; // secondary color
        public static string $successBg = '#64DD17'; // success color
        public static string $infoBg = '#29B6F6'; // info color
        public static string $warningBg = '#FFD600'; // warning color
        public static string $dangerBg = '#ef1c1c'; // danger color

        protected string|int $input_fc_moderate = '0';
        protected string $input_fc_emailTemplate = 'inherit';
        protected string $input_fc_emailtype = 'text';
        protected string $input_fc_email = '';
        protected string $input_fc_sender = '';
        protected string $input_fc_subject = '';
        protected string $input_fc_title = '';
        protected int $input_fc_depth = 3;
        protected string|int $input_fc_sort = 0;
        protected string|int $input_fc_spam = 3;
        protected string $input_fc_captcha = 'inherit';
        protected string|int $input_fc_outputorder = 0;
        protected string|int $input_fc_removeCSS = 0;
        protected string|int $input_fc_removeJS = 0;
        protected string|int $input_fc_userimage = 'none';
        protected string|int $input_fc_imagesize = 70;
        protected string|int $input_fc_stars = 0;
        protected string|int $input_fc_counter = 0;
        protected string|int $input_fc_voting = 0;
        protected string|int $input_fc_voting_lock = 7;
        protected string|int $input_privacy_show = 2;
        protected string|int $input_fc_comment_notification = 0;
        protected string|int $input_fc_queue_batch = 20;
        protected string|int $input_fc_quite_save = 0;
        protected array $moduleConfig = []; // array that holds all module config values
        protected array $frontendCommentsConfig = [];
        protected array $frontendFormsConfig = [];
        protected array $cronIntervals = [];

        // array of all fields inside the user template
        protected array $userfields = [];
        protected User $user;
        protected WireDatabasePDO $database;


        /**
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function __construct()
        {
            parent::__construct();

            // grab FrontendForms module to be able to use some methods of it
            $this->frontendForms = wire('modules')->get('FrontendForms');

            // grab configuration values from the FrontendForms module
            $this->frontendFormsConfig = $this->getFrontendFormsConfigValues();

            // set database object
            $this->database = $this->wire()->database;
        }

        /**
         * Get the info data about this module
         * @return array
         */
        public static function getModuleInfo(): array
        {
            return array(
                'title' => __('FrontendComments', __FILE__),
                'summary' => __('Field that let you store user comments on a page using the FrontendForms module.',
                    __FILE__),
                'href' => 'https://github.com/juergenweb/FieldtypeFrontendComments',
                'icon' => 'comment',
                'installs' => 'InputfieldFrontendComments',
                'permanent' => false,
                'version' => '1.0.0',
                'requires' => [
                    'FrontendForms>=2.1.53',
                    'PHP>=8.0',
                    'ProcessWire>=3',
                    'LazyCron'
                ],
                'author' => 'Jürgen Kern'
            );
        }

        /**
         * @return void
         */
        public function init(): void
        {
            parent::init();

            $this->addHookAfter('Page::render', $this, 'deleteSpam');
            // delete voting entries which are older than the selected time period
            $this->addHookAfter('Page::render', $this, 'deleteOldVoteEntries');
            // send queued emails as a batch to the users
            $this->addHookAfter('LazyCron::every30Seconds', $this, 'sendQueuedEmails');
            $this->addHookAfter('FieldtypeMulti::savePageField', $this, 'sendStatusChangeMail');

        }

        /**
         * Delete comments marked as SPAM after a given time as set in the input field configuration
         * @return void
         * @throws \ProcessWire\WireException
         */
        protected function deleteSpam(): void
        {
            // get all FrontendComments Inputfields
            $commentsFields = $this->wire('fields')->find('type=FieldtypeFrontendComments');
            foreach ($commentsFields as $field) {

                $table = $this->database->escapeTable($field->table);

                // delete old spam after a given time in days
                $expiredTime = time() - (86400 * $field->input_fc_spam);
                $query = $this->database->prepare("DELETE FROM `$table` WHERE status=:status AND created < :expiredTime");
                $query->bindValue(":status", InputfieldFrontendComments::spam, PDO::PARAM_INT);
                $query->bindValue(":expiredTime", $expiredTime);
                $query->execute();
            }

        }


        /**
         * Delete votes, which are older than the time period set inside the configuration
         * @return void
         * @throws \ProcessWire\WireException
         */
        protected function deleteOldVoteEntries(): void
        {

            $timePeriod = $this->input_fc_voting_lock;
            $currentDate = new DateTime(); // this will return today
            $comparingDate = $currentDate->sub(new DateInterval('P' . $timePeriod . 'D')); // substract the time period

            $commentsFields = $this->wire('fields')->find('type=FieldtypeFrontendComments');

            foreach ($commentsFields as $field) {
                $table = $this->database->escapeTable($field->table);
                $query = $this->database->prepare("DELETE FROM `$table` WHERE created < :comparingDate");
                $query->bindValue(":comparingDate", $comparingDate->getTimestamp());
                $query->execute();
            }
        }

        /**
         * Send notification mail to a commenter if the status of his comment has been changed
         * fe from pending approval to approve
         * @param \ProcessWire\HookEvent $event
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function sendStatusChangeMail(HookEvent $event): void
        {
            // run only if at least on email status notification is enabled
            if (array_key_exists('input_fc_status_change_notification', $this->frontendCommentsConfig)) {

                $fieldtypeMulti = $event->object;

                if ($fieldtypeMulti->className() != 'FieldtypeFrontendComments')
                    return;
                if (!$this->wire('session')->get('commentstatuschanges'))
                    return;

                $changedIDs = $this->wire('session')->get('commentstatuschanges');

                // get all comments with status change from the database
                $page = $event->arguments(0);
                $field = $event->arguments(1);
                $fieldName = $field->name;
                $commentEntries = $page->$fieldName;

                // create a notification object
                $notifications = new Notifications($commentEntries);

                $ids = implode('|', $changedIDs);
                $result = $commentEntries->find('id=' . $ids);

                foreach ($result as $comment) {

                    // send mails only if status is approved or spam
                    if (in_array((int)$comment->status, [InputfieldFrontendComments::approved, InputfieldFrontendComments::pendingApproval])) {

                        // check if sending of emails for this status is enabled
                        if(array_key_exists($comment->status, $this->frontendCommentsConfig)){
                            $notifications->sendStatusChangeEmail($comment, $field, $this->frontendFormsConfig);
                        }

                    }
                }
            }
            $this->wire('session')->remove('commentstatuschanges');

        }

        /**
         * Get all queued emails from the database and send the emails in batches
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        protected function sendQueuedEmails(): void
        {

            // do not send notification mails if stopqueue session is present
            if ($this->wire('session')->get('stopqueue')) {
                $this->wire('session')->remove('stopqueue');
                return;
            }

            bd('queue hook runs');
            // get all FrontendComments fields
            $fields = $this->wire('fields')->findByType('FieldtypeFrontendComments');

            foreach ($fields as $name => $value) {

                $field = $this->wire('fields')->get($name); // field object
                $table = 'field_' . $name . '_queues'; // the queue table name

                $sql = "SELECT * FROM $table ORDER BY id";
                $query = $this->database->prepare($sql);
                $query->execute();
                $list = $query->fetchAll();

                // shorten this list by the batch size
                $list = array_slice($list, 0, $this->input_fc_queue_batch);

                // send mails to each row in the list
                foreach ($list as $parameters) {
                    $parent_id = $parameters['parent_id'];
                    $email = $parameters['email'];
                    $comment_id = $parameters['comment_id'];
                    $page_id = $parameters['page_id'];
                    $field_id = $parameters['field_id'];

                    // get the code from the database
                    $commentTable = $this->database->escapeTable($field->table);
                    $statement = "SELECT code, email FROM $commentTable WHERE id=:parent_id";
                    try {
                        $query = $this->database->prepare($statement);
                        $query->bindValue(":parent_id", $parent_id, PDO::PARAM_INT);
                        $query->execute();
                        $result = $query->fetchAll();
                        $code = $result[0]['code'];
                    } catch (Exception $e) {
                        $error = $e->getMessage();
                    }

                    // get the page object
                    $page = $this->wire('pages')->get($page_id);

                    // get the field object
                    $field = $this->wire('fields')->get($field_id);
                    $fieldName = $field->name;

                    // get the comments' array containing all comments of the given field on the given page
                    $comments = $this->wire('pages')->get($page_id)->$fieldName;

                    if ($comments) {
                        $comment = $comments->findOne('id=' . $comment_id);

                        if ($comment) {

                            // set an array with table name and comment id to delete this queue entry after sending of the mail
                            $deleteField = $this->wire('fields')->get($field_id);
                            $deleteFieldTable = $this->database->escapeTable($deleteField->table) . '_queues';
                            $deleteRowID = $parameters['id'];

                            // create a notification object
                            $notifications = new Notifications($comments);
                            if ($notifications->sendNotificationAboutNewReply($comment, $page, $field, $code, $email)) {

                                // get the appropriate queued list item and delete it from the table
                                $statement = "DELETE FROM $deleteFieldTable WHERE id=:id ";
                                try {
                                    $query = $this->database->prepare($statement);
                                    $query->bindValue(":id", $deleteRowID, PDO::PARAM_INT);
                                    $query->execute();
                                } catch (Exception $e) {
                                    $error = $e->getMessage();
                                }
                            }
                        }
                    }
                }
            }
        }

        /**
         * Get all fields inside the user template which can be selected to map form fields.
         * Please note: Only user fields, which are editable by the user will be taken into account
         * @return array - key: field ID, value: field name
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function getUserFields(): array
        {
            // get array of all editable user template fields

            $fields = $this->wire('modules')->getModule('ProcessProfile', ['noPermissionCheck' => true]);
            $all_userfields = $fields->data['profileFields'];
            // ignore these fields from the user template
            $ignoreFields = ['pass', 'roles', 'language', 'admin_theme', 'tfa_type'];
            $userfields = array_diff($all_userfields, $ignoreFields);
            $linkFields = [];
            $linkFields['none'] = $this->_('none');
            foreach ($userfields as $fieldname) {
                $field = $this->wire('fields')->get($fieldname);
                $linkFields[$field->id] = $field->name;
            }
            return $linkFields;
        }

        /**
         * Select user fields depending on the Fieldtype (class name)
         * @param string $classname
         * @return array
         * @throws WireException
         * @throws WirePermissionException
         */
        protected function getUserfieldsOfType(string $classname): array
        {
            $fields = [];
            foreach ($this->userfields as $id => $name) {
                $field = $this->wire('fields')->get($id);
                if (isset($field->type)) {
                    $fields['none'] = $this->_('no selection'); // add an empty option
                    if ($field->type->className() == $classname) {
                        $fields[$id] = $name;
                    }
                }
            }
            $this->userimagefields = $fields;
            return $fields;
        }

        /**
         *  Return a blank ready-to-populate value
         * @param Page $page
         * @param Field $field
         * @return CommentArray
         * @throws WireException
         */
        public function getBlankValue(Page $page, Field $field): CommentArray
        {
            $commentArray = $this->wire(new CommentArray());
            $commentArray->setPage($page);
            $commentArray->setField($field);
            $commentArray->setTrackChanges(); // enable tracking of changes
            return $commentArray;
        }

        /**
         * Given a value, make it clean and of the correct type for storage within a Page
         *
         * @param Page $page
         * @param Field $field
         * @param $value
         * @return CommentArray
         * @throws WireException
         */
        public function sanitizeValue(Page $page, Field $field, $value): CommentArray
        {

            // if the value is of type CommentArray -> return it
            if ($value instanceof CommentArray) {
                return $value;
            }

            // value is not of type CommentArray -> convert it to a Comment Array
            /** @var CommentArray $commentArray */
            $commentArray = $this->wire()->pages->get($field->name);

            if (!$value) return $commentArray;

            if ($value instanceof Comment) return $commentArray->add($value);
            if (!is_array($value)) $value = array($value);

            foreach ($value as $comment) $commentArray->add($comment);

            return $commentArray;
        }

        /**
         * Convert from DB storage to API value for displaying on a template page
         *
         * @param Page $page
         * @param Field $field
         * @param string|int|array $value
         * @return CommentArray
         * @throws WireException
         */
        public function ___wakeupValue(Page $page, Field $field, $value): CommentArray
        {
            // if value ist type of CommentArray -> return it
            if ($value instanceof CommentArray) return $value;

            // if no Comment Array value is present ->
            // instantiate a new object with blank values if no value is present
            $commentArray = $this->getBlankValue($page, $field);

            if (empty($value)) return $commentArray;

            if (!is_array($value)) $value = [$value];

            foreach ($value as $item) {

                // create a new comment instance from each item
                $comment = $this->wire(new Comment($item, $commentArray));
                $comment->page = $page; // set the page, where the comment belongs to
                $comment->field = $field; // set the field, where the comment belongs to

                foreach ($item as $name => $value) {
                    if ($name === 'data')
                        $name = 'text';
                    $comment->set($name, $value);
                }

                $commentArray->add($comment);

            }

            $commentArray->resetTrackChanges();

            // sort, according to the input field settings (newest to oldest or vice versa)
            if ($this->input_fc_sort == 1) {
                $commentArray->sort("-created"); // sort newest to oldest
            }

            return $commentArray;
        }

        /**
         * Convert from API to DB storage value.
         * Multi-value field contains an array as value
         *
         * @param Page $page
         * @param Field $field
         * @param string|int|array|object $value
         * @return array
         * @throws Exception
         */
        public function ___sleepValue(Page $page, Field $field, $value): array
        {

            $sleepValue = [];
            if (!$value instanceof CommentArray) return $sleepValue;

            $sanitizer = $this->wire()->sanitizer;

            // convert each Comment to an array within sleepValue
            foreach ($value as $comment) {

                // sanitize especially values that will be submitted via the form
                $a = array(
                    'id' => $comment->id,
                    'status' => $sanitizer->int($comment->status),
                    'data' => $sanitizer->textarea($comment->text),
                    'author' => $sanitizer->maxLength($comment->author, 128, 128 * 3),
                    'email' => $sanitizer->maxLength($comment->email, 128, 128 * 3),
                    'created' => $comment->created,
                    'user_id' => $comment->user_id,
                    'parent_id' => $sanitizer->int($comment->parent_id),
                    'ip' => $comment->ip,
                    'user_agent' => $comment->user_agent,
                    'code' => $comment->code,
                    'remote_flag' => $comment->remote_flag,
                    'notification' => $comment->notification,
                    'stars' => $comment->stars,
                    'upvotes' => $comment->upvotes,
                    'downvotes' => $comment->downvotes,
                );

                $sleepValue[] = $a;

            }

            return $sleepValue;
        }

        /**
         * Take the sleep value and save the data (comment) to the database
         * expects values as an array, so we convert the $value object to an array
         * @param Page $page
         * @param Field $field
         * @return bool
         * @throws WireException
         * @noinspection SqlNoDataSourceInspection
         */
        public function ___savePageField(Page $page, Field $field): bool
        {

            // save the data only if the page and the field exist
            if (!$page->id || !$field->id) return false;

            // get all comments as a CommentArray, the database object and the table name
            $allItems = $page->get($field->name); // returns CommentArray
            $table = $this->database->escapeTable($field->table); // returns the database table name (fe field_my_comment-table)

            // if there are no items (comments), stop the saving process here
            if (!$allItems) return false;

            // if there are no changes in the comments at all and no new comment -> stop the saving process here
            if (!$allItems->isChanged() && !$page->isChanged($field->name)) return true;

            $maxSort = 0;

            // create a blank new CommentArray for saving
            $items = $allItems->makeNew();
            $changedItems = [];
            foreach ($allItems as $item) {
                // check if an existing comment has been changed or a new comment was submitted
                if ($item->isChanged('status')) {
                    $changedItems[] = $item->id;
                }
                // if yes -> add this item to the newly created CommentArray for saving
                if ($item->isChanged() || !$item->id) $items->add($item);
                if ($item->sort > $maxSort) $maxSort = $item->sort;
            }
            // set array for changed items containing id and status of each changed item
            if ($changedItems) {
                $this->wire('session')->set('commentstatuschanges', $changedItems);
            }

            // no new comments or updated comments inside the new CommentsArray -> stop the saving process here

            // convert the values for storage in the database
            $values = $this->sleepValue($page, $field, $items);
            $value = reset($values); // Set the internal pointer of the array to its first element

            // get all the col names as an array
            $keys = is_array($value) ? array_keys($value) : array('data'); // get all array keys

            // cycle through the values, executing an update or an insert query for each
            $commentStatusBefore = [];
            foreach ($values as $value) {

                $binds = array();

                // check if it is a new entry or an update
                $sql = $value['id'] ? "UPDATE " : "INSERT INTO ";
                $sql .= "`$table` SET pages_id=:pages_id, ";
                $binds['pages_id'] = $page->id;

                // if the value is not an associative array, then force it to be one
                if (!is_array($value)) $value = array('data' => $value);
                // cycle through the keys, which represent DB fields (f.e. data, description, etc.) and generate the update query
                foreach ($keys as $key) {
                    if ($key == 'id') {
                        continue;
                    }
                    if ($key == 'sort' && !$value['id']) {
                        continue;
                    }
                    $v = $value[$key];

                    $col = $this->database->escapeCol($key);
                    if (!is_null($v)) {
                        $sql .= "$col=:$col, ";
                        $binds[$col] = $v;
                    }
                }
                // old comment, which will be updated
                if ($value['id']) {
                    $sql = rtrim($sql, ', ') . " WHERE id=:id"; // . (int) $value['id'];
                    $binds['id'] = (int)$value['id'];
                } else {
                    // new comment
                    $sql .= "sort=:sort";
                    $binds['sort'] = ++$maxSort;
                }

                // save the data to the database
                try {

                    $query = $this->database->prepare($sql); // create the query string

                    // bind all values to the query string
                    foreach ($binds as $k => $v) {
                        $query->bindValue(":$k", $v);
                    }

                    // execute the query to save the comment in the database
                    $result = $query->execute();
                    $error = '';
                } catch (Exception $e) {
                    $result = false;
                    $error = $e->getMessage();
                }

                // if an error occurs, display an error message and log the error
                if (!$result) {
                    $this->error("Error saving comment id $value[id]: $error", Notice::log);
                }

            }
            return true;
        }


        /**
         * @throws \ProcessWire\WireException
         */
        public function ___updateStatus($comment = null, array $queryParams, $table, $notification, $code, $alert)
        {
            if (!is_null($comment)) {

                // comment with this code was found inside the database
                // check for the query strings
                switch (true) {
                    case (array_key_exists('status', $queryParams)):

                        // 1) change the status of the comment via an email link to approved or spam

                        // sanitize the value "status" to be a string first
                        $newStatus = $this->wire('sanitizer')->string($queryParams['status']);

                        // check if the value is only '0' or '1'
                        $newStatus = in_array($newStatus, ['0', '1']) ? $newStatus : null;

                        if (!is_null($newStatus)) {

                            // sanitize $newStatus to be integer
                            $newStatus = $this->wire('sanitizer')->int($newStatus);

                            // check if comment has remote_flag = 0, which means the status has not been changed before
                            if ($comment->remote_flag === InputfieldFrontendComments::pendingApproval) {

                                $sql = "UPDATE $table SET status=:status, remote_flag=:remote_flag WHERE id=:id";

                                // save the data to the database
                                try {

                                    $query = $this->database->prepare($sql);
                                    $query->bindValue(":status", $newStatus, PDO::PARAM_INT);
                                    $query->bindValue(":remote_flag", 1, PDO::PARAM_INT);
                                    $query->bindValue(":id", $comment->id, PDO::PARAM_INT);

                                    // execute the query to save the comment in the database
                                    if ($query->execute()) {
                                        // set the status of the new comment to a session variable for later output of the success message
                                        $this->wire('session')->set('commentstatuschange', $newStatus);
                                        // make a redirect if comment status has been changed to approved to show the new comment
                                        if ($newStatus === InputfieldFrontendComments::approved) {
                                            $this->wire('session')->set('approvedid', $comment->id);
                                            $this->wire('session')->redirect('.');
                                        }
                                    }
                                } catch (Exception $e) {
                                    $this->log($e->getMessage()); // log the error message
                                    $this->wire('session')->set('commentstatuschange', 3); // 3 stands for error
                                }
                            } else {
                                $alert->setCSSClass('alert_dangerClass');
                                $alert->setText($this->_('The status of the comment has already been changed. For security reasons, however, this is only allowed once via mail link. If you want to change the status once more, you have to login to the backend.'));
                            }
                        }

                        break;

                    case (array_key_exists('notification', $queryParams)):
                        if ($notification == 0) {
                            $this->wire('session')->set('notifystatuschange', '1');
                        } else {
                            // 2) change the status of mail notification to 0, which means to not send notification mails in the future
                            $sql = "UPDATE $table SET notification=:notification WHERE code=:code";
                            // save the data to the database
                            try {
                                $query = $this->database->prepare($sql);
                                $query->bindValue(":notification", 0, PDO::PARAM_INT);
                                $query->bindValue(":code", $code);
                                // execute the query to save the comment in the database
                                if ($query->execute()) {
                                    // set the status of the new comment to a session variable for later output of the success message
                                    $this->wire('session')->set('notifystatuschange', '0');
                                } else {
                                    $this->wire('session')->set('notifystatuschange', '3');
                                }
                            } catch (Exception $e) {
                                $this->log($e->getMessage()); // log the error message
                                $this->wire('session')->set('notifystatuschange', 3); // 3 stands for error
                            }
                        }
                        break;

                }
            }
        }

        /**
         * User is not allowed to change this fieldtype to another fieldtype
         *
         * @param Field $field
         * @return null
         *
         */
        public function ___getCompatibleFieldtypes(Field $field): null
        {
            return null;
        }

        /**
         * Database schema for the FrontendComments Fieldtype
         * @param Field $field
         * @return array
         * @throws \ProcessWire\WireException
         */
        public function getDatabaseSchema(Field $field): array
        {

            $schema = parent::getDatabaseSchema($field);
            $table = $field->getTable();
            $database = $this->database;

            $schema['id'] = "int unsigned NOT NULL auto_increment";
            $schema['status'] = "tinyint(3) NOT NULL default '0'";
            $schema['author'] = "varchar(128) NOT NULL default ''";
            $schema['email'] = "varchar(255) NOT NULL default ''";
            $schema['data'] = "text NOT NULL";
            $schema['sort'] = "int unsigned NOT NULL";
            $schema['created'] = "int unsigned NOT NULL";
            $schema['user_id'] = "int unsigned NOT NULL";
            $schema['ip'] = "varchar(15) NOT NULL default ''";
            $schema['user_agent'] = "varchar(255) NOT NULL default ''";
            $schema['parent_id'] = "int unsigned NOT NULL default 0";
            $schema['code'] = "varchar(128) NOT NULL default ''";
            $schema['remote_flag'] = "tinyint(3) NOT NULL default '0'";
            $schema['notification'] = "tinyint(3) NOT NULL default '0'";
            $schema['stars'] = "tinyint(3) unsigned default NULL";
            $schema['upvotes'] = "int unsigned default 0";
            $schema['downvotes'] = "int unsigned default 0";

            // indexes, for any fields that need to be searchable from selectors
            $schema['keys']['primary'] = "PRIMARY KEY (`id`)";
            $schema['keys']['pages_id_sort'] = "KEY `pages_id_sort` (`pages_id`, `sort`)";
            $schema['keys']['status'] = "KEY `status` (`status`, `email`)";
            $schema['keys']['pages_id'] = "KEY `pages_id` (`pages_id`,`status`,`created`)";
            $schema['keys']['created'] = "KEY `created` (`created`, `status`)";
            $schema['keys']['data'] = "FULLTEXT KEY `data` (`data`)";
            $schema['keys']['code'] = "KEY `code` (`code`, `status`)";

            // create table for storing the up- and down-votes user data (user id, browser, date/time,...)
            // This table is for checking, if a user has voted within a given time period
            if (!$database->tableExists("{$table}_votes")) {

                $sql = '
            CREATE TABLE ' . $table . '_votes (
                id int unsigned NOT NULL auto_increment,
                comment_id int unsigned NOT NULL,
                vote tinyint NOT NULL,
                created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                ip varchar(15) NOT NULL default "",
                user_id int unsigned NOT NULL default 0,
                user_agent varchar(255) NOT NULL,
                PRIMARY KEY (id),
                INDEX created (created)
            )
            ';

                $database->exec($sql);
            }

            // create a table for queuing emails that will be sent to users
            // the table contains the comment id and the email, where the mail should be sent to
            if (!$database->tableExists("{$table}_queues")) {

                $sql = '
            CREATE TABLE ' . $table . '_queues (
                id int unsigned NOT NULL auto_increment,
                parent_id int unsigned NOT NULL,
                comment_id int unsigned NOT NULL,              
                email varchar(255) NOT NULL,
                page_id int unsigned NOT NULL,
                field_id int unsigned NOT NULL,
                PRIMARY KEY (id),
                INDEX created (comment_id)
            )
            ';

                $database->exec($sql);
            }

            return $schema;
        }

        /**
         * Delete the given field, which implies: drop the table $field->table, the table_votes and the table_queues
         *
         * This should only be called by the Fields class since fieldgroups_fields lookup entries must be deleted
         * before this method is called.
         *
         * @param Field $field Field object
         * @return bool True on success, false on DB delete failure.
         *
         */
        public function ___deleteField(Field $field): bool
        {
            $database = $this->database;
            $table = $database->escapeTable($field->table);

            try {
                $result = $database->exec("DROP TABLE `$table`"); // delete the table field
            } catch (Exception $e) {
                $result = false;
                $this->error($e->getMessage());
            }
            if ($result !== false) try {
                $database->exec("DROP TABLE `{$table}_votes`"); // delete the votes table field too
            } catch (Exception $e) {
                // ok to ignore, as table may not exist
            }
            if ($result !== false) try {
                $database->exec("DROP TABLE `{$table}_queues`"); // delete the queue table field too
            } catch (Exception $e) {
                // ok to ignore, as table may not exist
            }
            return (bool)$result;
        }

        /**
         * Return the Inputfield used to collect input for a field of this type
         *
         * @param Page $page
         * @param Field $field
         * @return Module|null
         * @throws WirePermissionException|WireException
         */
        public function getInputfield(Page $page, Field $field): Module|null
        {
            $inputfield = $this->wire()->modules->get('InputfieldFrontendComments');
            if (!$inputfield) return null;
            $inputfield->class = $this->className();
            return $inputfield;
        }

        /**
         * @throws WireException
         * @throws WirePermissionException
         */
        public function ___getConfigInputfields(Field $field): InputfieldWrapper
        {
            $languages = $this->wire('languages');
            $modules = $this->wire()->modules;
            $inputfields = parent::___getConfigInputfields($field);
            $this->userfields = $this->getUserFields();
            $userimages = $this->getUserfieldsOfType('FieldtypeImage');

            /** @var InputfieldRadios $f */
            $moderate = $modules->get('InputfieldRadios');
            $moderate->label = $this->_('Comment moderation');
            $moderate->description = $this->_('This determines when a newly posted comment will appear on your site.');
            $moderate->attr('name', 'input_fc_moderate');
            $moderate->attr('value', (int)$field->input_fc_moderate);
            $moderate->addOption(self::moderateNone, $this->_('None - Comments posted immediately'));
            $moderate->addOption(self::moderateAll, $this->_('All - All comments must be approved by user with page edit access'));
            $moderate->addOption(self::moderateNew, $this->_('Only New - Only comments from users without prior approved comments require approval'));
            $inputfields->append($moderate);

            /** @var InputfieldCheckbox $f */
            $quietsave = $modules->get('InputfieldCheckbox');
            $quietsave->attr('name', 'input_fc_quiet_save');
            $quietsave->attr('value', 1);
            $quietsave->attr('checked', $field->input_fc_quiet_save ? 'checked' : '');
            $quietsave->label = $this->_('Quiet save?');
            $quietsave->description = $this->_('When checked, the page modification time and user will not be updated when a comment will be changed in the backend.');
            $quietsave->notes = $this->_('Only to mention: The modification time and user will only be changed, if you save the page in the backend. Changing the comment status via mail link does not affect the modification time and user.');
            $inputfields->append($quietsave);

            /**
             * Field configuration fieldset
             */

            /**  $confFieldset */
            $confFieldset = $modules->get('InputfieldFieldset');
            $confFieldset->label = $this->_('Form fields configuration');
            $confFieldset->collapsed = true;
            $confFieldset->columnWidth = 100;
            $confFieldset->icon = 'fa-list';

            $userimage = $modules->get('InputfieldSelect');
            $userimage->label = $this->_('Select the field for the user image');
            $userimage->attr('name', 'input_fc_userimage');
            //get all possible image fields from the user template
            $userimage->addOptions($userimages);
            $value = (is_null($field->input_fc_userimage)) ? $this->input_fc_userimage : $field->input_fc_userimage;
            $userimage->attr('value', $value);
            $userimage->required = 1;
            $userimage->columnWidth = 50;
            $userimage->description = $this->_('Select the field of the user template which contains the user image');
            $userimage->notes = $this->_('Only user fields of the type "FieldtypeImage" and the configuration setting for a single image will be displayed (if present).');
            $confFieldset->add($userimage);

            $imagesize = $modules->get('InputfieldInteger');
            $imagesize->label = $this->_('Set the size of the image');
            $imagesize->attr('name', 'input_fc_imagesize');
            $imagesize->columnWidth = 50;
            $imagesize->required = 1;
            $imagesize->description = $this->_('Enter a value in px. The image will be displayed squared.');
            $value = (is_null($field->input_fc_imagesize)) ? $this->input_fc_imagesize : $field->input_fc_imagesize;
            $imagesize->attr('value', $value);
            $confFieldset->add($imagesize, $inputfields);

            $inputfields->add($confFieldset);

            /**  $emailFieldset */
            $emailFieldset = $modules->get('InputfieldFieldset');
            $emailFieldset->label = $this->_('Default email configuration');
            $emailFieldset->collapsed = true;
            $emailFieldset->columnWidth = 100;
            $emailFieldset->icon = 'fa-envelope';

            // choose whether to use an email template or not
            if ($this->frontendForms->getEmailTemplates()) {
                $emailTemplate = $modules->get('InputfieldSelect');
                $emailTemplate->label = $this->_('Select an email template');
                $emailTemplate->attr('name', 'input_fc_emailTemplate');
                // create options
                $templates = [
                    'inherit' => $this->_('inherit from FrontendForms settings'),
                    'none' => $this->_('no HTML template (plain text only)')
                ];
                foreach ($this->frontendForms->getEmailTemplates() as $template) {
                    $templates[$template] = ucfirst($template);
                }
                $emailTemplate->addOptions($templates);
                $value = (is_null($field->input_fc_emailTemplate)) ? $this->input_fc_emailTemplate : $field->input_fc_emailTemplate;
                $emailTemplate->attr('value', $value);
                $emailTemplate->required = 1;
                $emailTemplate->description = $this->_('Select if you want to use a HTML template for the notification emails or not.');
                $emailTemplate->notes = $this->_('Inherit from FrontendForms will take the setting from this module.');
                $emailFieldset->add($emailTemplate);

            }

            // set email manually or use a PW field value
            $emailtype = $modules->get('InputfieldSelect');
            $emailtype->label = $this->_('Email address(es) for the notification email');
            $emailtype->description = $this->_('Select, if you want to enter the receiver email address(es) for the notification mails manually or if you want to select users as recipients.');
            $emailtype->attr('name', 'input_fc_emailtype');
            $emailtype->addOptions([
                'text' => $this->_('Enter email address(es) manually'),
                'pwfield' => $this->_('Select users as recipients')
            ]);
            $emailtype->attr('value', $field->input_fc_emailtype);
            $emailtype->columnWidth = 50;
            $emailtype->required = 1;
            $emailtype->notes = '';
            $emailFieldset->add($emailtype);

            // email address where the emails should be sent to (fe. noreply@mycompany.com)
            $email = $modules->get('InputfieldEmail');
            $email->label = $this->_('Default email address(es) as text');
            $email->attr('name', 'input_fc_default_to');
            $email->attr('value', $field->input_fc_default_to);
            $email->columnWidth = 25;
            $email->showIf = 'input_fc_emailtype=text';
            $email->required = 1;
            $email->requiredIf = 'input_fc_emailtype=text';
            $email->description = $this->_('Enter one ore more email addresses separated by a comma.');
            $email->notes = $this->_('Fe email1@mydomain.com,email2@mydomain.com.');
            $emailFieldset->add($email);

            // select one or more users as recipients
            // this field overwrites the text field for the email address
            $emailField = $modules->get('InputfieldAsmSelect');
            $emailField->label = $this->_('Recipients for the notification email');
            $emailField->attr('name', 'input_fc_defaultPWField_to');
            $emailField->required = 1;
            $emailField->requiredIf = 'input_fc_emailtype=pwfield';
            // create options that contain users (excluding registered)
            $users = $this->wire('users')->find('roles!=registered,id!=40,sort=roles');
            $userFields = [];
            foreach ($users as $user) {
                $userFields[$user->email] = $user->name . ' [' . $user->email . ']';
            }
            $emailField->addOptions($userFields);
            $emailField->attr('value', $field->input_fc_defaultPWField_to);
            $emailField->description = $this->_('Select one or more users that should receive a notification about new comments.');
            $emailField->notes = $this->_('Users with the role "registered" will not be displayed, because they are not allowed to get notification emails.');
            $emailField->columnWidth = 25;
            $emailField->showIf = 'input_fc_emailtype=pwfield';
            $emailFieldset->add($emailField);

            // enter the email address from where the emails should be sent (fe. no-reply@mycompany.com)
            $email = $modules->get('InputfieldEmail');
            $email->label = $this->_('From email address');
            $email->attr('name', 'input_fc_email');
            $email->attr('value', $field->input_fc_email);
            if ($languages) {
                $email->useLanguages = true;
                foreach ($languages as $language) {
                    if ($language->isDefault()) continue;
                    $email->attr("value$language", (string)$field->get("input_fc_email$language->id"));
                }
            }
            $email->description = $this->_('This email address will be displayed as the sender email address of the emails sent by this module.');
            $email->columnWidth = 50;
            $email->notes = sprintf($this->_('If no email address will be entered, %s will be displayed instead as the sender address.'), '"' . $this->_('comment-notification') . '@' . $_SERVER["SERVER_NAME"] . '"');
            $emailFieldset->add($email);

            // enter the sender of the emails (fe. My Company)
            $sender = $modules->get('InputfieldText');
            $sender->label = $this->_('From name');
            $sender->attr('name', 'input_fc_sender');
            $sender->attr('value', $field->input_fc_sender);
            if ($languages) {
                $sender->useLanguages = true;
                foreach ($languages as $language) {
                    if ($language->isDefault()) continue;
                    $sender->attr("value$language", (string)$field->get("input_fc_sender$language->id"));
                }
            }
            $sender->placeholder = $this->_('fe. My company');
            $sender->description = $this->_('This name will be displayed as the sender name of the emails sent by this module.');
            $sender->notes = $this->_('If no sender name will be entered, than the sender email address will be used as the sender name.');
            $sender->columnWidth = 50;
            $emailFieldset->add($sender);

            // input_fc_comment_notification
            $notification = $modules->get('InputfieldRadios');
            $notification->attr('name', 'input_fc_comment_notification');
            $notification->optionColumns = 1;
            $notification->label = $this->_('Commenter email notification');
            $notification->description = $this->_('Send commenters notification emails about new replies');
            $notification->addOption(0, $this->_('Disabled'));
            $notification->addOption(Comment::flagNotifyReply, $this->_('Commenters can receive email notifications of replies to their comment only'));
            $notification->addOption(Comment::flagNotifyAll, $this->_('Commenters can receive email notifications for all new replies to a comment on the page'));
            $notification->attr('value', (int)$field->get('input_fc_comment_notification'));
            $emailFieldset->add($notification);

            // input_fc_status_change_notification
            $statusnotification = $modules->get('InputfieldCheckboxes');
            $statusnotification->attr('name', 'input_fc_status_change_notification');
            $statusnotification->label = $this->_('Send notification email to commenter on status change');
            $statusnotification->description = $this->_('If a moderator changes the status of a comment, select on which status change the commenter should be informed via email.');
            $statusnotification->addOption(InputfieldFrontendComments::approved, sprintf($this->_('Send notification email if status has been changed to approved'), InputfieldFrontendComments::statusTexts()[InputfieldFrontendComments::approved]));
            $statusnotification->addOption(InputfieldFrontendComments::spam, sprintf($this->_('Send notification email if status has been changed to SPAM'), InputfieldFrontendComments::statusTexts()[InputfieldFrontendComments::approved]));
            $statusnotification->attr('value', (int)$field->get('input_fc_status_change_notification'));
            $statusnotification->notes = $this->_('If a box is checked, the commenter will receive an email if the comment status will be changed by a moderator in the backend or via email link. You can prevent this behavior by unchecking a box.');
            $emailFieldset->add($statusnotification);

            $inputfields->append($emailFieldset);

            $fieldset = $modules->get('InputfieldFieldset');
            $fieldset->label = $this->_('Output rendering');
            $fieldset->collapsed = 1;// by default, this fieldset should be collapsed
            $fieldset->description = $this->_('Change some parameters to get the preferred output.');
            $fieldset->icon = 'fa-cog';

            // field to enter the number of decimals (fe 2) -> will be appended after the inputfield
            $f = $this->modules->get('InputfieldInteger');
            $f->attr('name+id', 'input_fc_depth');
            $f->attr('type', 'number');
            $f->label = $this->_('Replay depth');
            $value = (is_null($field->input_fc_depth)) ? $this->input_fc_depth : $field->input_fc_depth;
            $f->attr('value', $value);
            $f->attr('size', 10);
            $f->attr('min', 0);
            $f->attr('max', 10);
            $f->required(true);
            $f->description = $this->_('Choose the number of depth for threaded comments');
            $f->notes = $this->_('Specify 0 for traditional flat chronological comments. For threaded comments (replies appear with comment being replied to) specify the maximum depth allowed for replies (0 to 3 recommended).');
            $fieldset->append($f);

            // field to enter the number of decimals (fe 2) -> will be appended after the inputfield
            $f = $this->modules->get('InputfieldCheckbox');
            $f->attr('name+id', 'input_fc_sort');
            $f->label = $this->_('Sort order');
            $f->attr('value', $field->input_fc_sort);
            $f->attr('checked', $field->input_fc_sort ? 'checked' : '');
            $f->label2 = $this->_('Sort newest to oldest');
            $f->description = $this->_('Set the sort order for the comments');
            $f->notes = $this->_('By default, comments will be sort chronologically (oldest to newest). To reverse that behavior check this box.');
            $fieldset->append($f);

            // field to reverse the output order of form and comments
            $f = $this->modules->get('InputfieldCheckbox');
            $f->attr('name+id', 'input_fc_outputorder');
            $f->label = $this->_('Output order');
            $f->attr('value', $field->input_fc_outputorder);
            $f->attr('checked', $field->input_fc_outputorder ? 'checked' : '');
            $f->label2 = $this->_('Show form after comments');
            $f->description = $this->_('Reverse the order of the output of form and comments');
            $f->notes = $this->_('By default, the form will be displayed before the comments. To reverse that behavior check this box.');
            $fieldset->append($f);

            // field to show or hide the star rating
            $f = $this->modules->get('InputfieldCheckbox');
            $f->attr('name+id', 'input_fc_stars');
            $f->label = $this->_('Use star rating');
            $f->attr('value', $field->input_fc_stars);
            $f->attr('checked', $field->input_fc_stars ? 'checked' : '');
            $f->label2 = $this->_('Show star rating');
            $f->description = $this->_('If you want to offer star rating, please check the box');
            $fieldset->append($f);

            // field to show or hide the character counter under the comment text field
            $f = $this->modules->get('InputfieldCheckbox');
            $f->attr('name+id', 'input_fc_counter');
            $f->label = $this->_('Show/hide character counter under the textarea field');
            $f->attr('value', $field->input_fc_counter);
            $f->attr('checked', $field->input_fc_counter ? 'checked' : '');
            $f->label2 = $this->_('Hide character counter');
            $f->description = $this->_('By default, a character counter will be displayed under the comment text field to inform the user, how many characters are left until the max. limit of 1024 characters is reached.');
            $fieldset->append($f);

            // field to show or hide comment rating
            $f = $this->modules->get('InputfieldCheckbox');
            $f->attr('name+id', 'input_fc_voting');
            $f->label = $this->_('Show/hide voting of comments');
            $f->attr('value', $field->input_fc_voting);
            $f->attr('checked', $field->input_fc_voting ? 'checked' : '');
            $f->label2 = $this->_('Enable voting of comments');
            $f->description = $this->_('By checking the box you offer visitors the possibility to rate comments (up-votes and down-votes).');
            $f->columnWidth = 50;
            $fieldset->append($f);

            //input_fc_voting_lock
            $f = $this->modules->get('InputfieldInteger');
            $f->attr('name+id', 'input_fc_voting_lock');
            $f->attr('type', 'number');
            $f->label = $this->_('Lock in days before voting can be done again');
            $value = (is_null($field->input_fc_voting_lock)) ? $this->input_fc_voting_lock : $field->input_fc_voting_lock;
            $f->attr('value', $value);
            $f->attr('size', 10);
            $f->attr('min', 1);
            $f->required(true);
            $f->description = $this->_('To prevent multiple ratings from the same user, this module checks if the user have voted before. Please enter a time period in days during which further rating is not allowed.');
            $f->notes = $this->_('The user will be identified by using data of his Internet fingerprint. This means that the IP address, the browser system and the user ID will be compared with entries in the database. If an entry with the same data will be found, then the rating is not allowed. Entries in the database which are older than the time period selected above will be deleted automatically and the user will be allowed to rate again.');
            $f->columnWidth = 50;
            $fieldset->append($f);

            // Show or hide privacy checkbox or text on form
            $privacy_show = $this->wire()->modules->get('InputfieldSelect');
            $privacy_show->label = $this->_('Add privacy text or privacy checkbox to the form');
            $privacy_show->description = $this->_('Select if you want to show a privacy text only or a privacy checkbox above the submit button');
            $options = [
                $this->_('Do not show anything'),
                $this->_('Show checkbox'),
                $this->_('Show text')
            ];
            $privacy_show->addOptions($options);
            $privacy_show->defaultValue = '2';
            $privacy_show->attr('value', $this->input_privacy_show);
            $privacy_show->attr('name', 'input_privacy_show');
            $privacy_show->notes = $this->_('You can disable the display of the privacy text/checkbox, but you should be aware that this may lead to legal consequences if a privacy notice is required in your country.');
            $fieldset->append($privacy_show);

            $inputfields->append($fieldset);

            /**  $spamFieldset */
            $spamFieldset = $modules->get('InputfieldFieldset');
            $spamFieldset->label = $this->_('Spam protection');
            $spamFieldset->collapsed = true;
            $spamFieldset->columnWidth = 100;
            $spamFieldset->icon = 'fa-ban';

            // field to enter the number of decimals (fe 2) -> will be appended after the inputfield
            $f = $this->modules->get('InputfieldInteger');
            $f->attr('name+id', 'input_fc_spam');
            $f->attr('type', 'number');
            $f->label = $this->_('Number of days after which to delete spam');
            $value = (is_null($field->input_fc_spam)) ? $this->input_fc_spam : $field->input_fc_spam;
            $f->attr('value', $value);
            $f->attr('size', 10);
            $f->attr('min', 0);
            $f->required(true);
            $f->description = $this->_('After the number of days indicated, spam will be automatically deleted.');
            $spamFieldset->append($f);

            // captcha
            $captcha = $modules->get('InputfieldSelect');
            $captcha->label = $this->_('CAPTCHA');
            $captcha->description = $this->_('Select, if you want to use a CAPTCHA for the comment form.');
            $captcha->notes = $this->_('If you receive a lot of spam comments, you can enable a CAPTCHA to prevent spam bots from filling out the form.');
            $captcha->attr('name', 'input_fc_captcha');
            // grab CAPTCHA types from FrontendForms module
            $modulePath = $this->wire('config')->get('paths')->siteModules . 'FrontendForms/';
            $captchaTypes = $this->wire('files')->find($modulePath . 'Formelements/Captcha/variants/',
                ['recursive' => 0]);
            $captcha->addOption('inherit', $this->_('Inherit from FrontendForms'));
            $captcha->addOption('none', $this->_('No CAPTCHA'));

            foreach ($captchaTypes as $file) {
                $className = pathinfo($file, PATHINFO_FILENAME);
                $cname = 'FrontendForms\\' . $className;
                $option = new $cname();
                $captcha->addOption($className, $option->title);
            }
            $value = (is_null($field->input_fc_captcha)) ? $this->input_fc_captcha : $field->input_fc_captcha;
            $captcha->attr('value', $value);
            $captcha->required = 1;
            $spamFieldset->add($captcha, $inputfields);

            $inputfields->append($spamFieldset);

            /**  CSS + JS fieldset */
            $cssjsFieldset = $modules->get('InputfieldFieldset');
            $cssjsFieldset->label = $this->_('JS and CSS');
            $cssjsFieldset->collapsed = true;
            $cssjsFieldset->columnWidth = 100;
            $cssjsFieldset->icon = 'fa-code';

            /** @var InputfieldMarkup $f */
            $f = $modules->get('InputfieldMarkup');
            $f->label = $this->_('CSS for front-end comments output');
            $f->value =
                "<p>If you do not use a CSS framework, please copy and paste the following into the document <code>&lt;head&gt;</code> of your site:</p>" .
                "<pre style='border-left: 4px solid #ccc; padding-left: 1em;'>&lt;link rel='stylesheet' type='text/css' href='&lt;?=\$config-&gt;urls-&gt;FieldtypeFrontendComments?&gt;&#92assets&#92frontendcomments.css' /&gt;</pre>" .

                $cssjsFieldset->add($f);

            /** @var InputfieldMarkup $f */
            $f = $modules->get('InputfieldMarkup');
            $f->label = $this->_('JS for front-end comments output');
            $f->value =
                "<p>Please copy and paste the following into the document before the closing <code>&lt;/body&gt;</code> tag:</p>" .
                "<p><pre style='border-left: 4px solid #ccc; padding-left: 1em;'>&lt;script type='text/javascript' src='&lt;?=\$config-&gt;urls-&gt;FieldtypeFrontendComments?&gt;&#92assets&#92frontendcomments.js'&gt;&lt;/script&gt;</pre></p>";
            $cssjsFieldset->add($f);

            $inputfields->append($cssjsFieldset);

            // output all input fields (parent and custom)
            return $inputfields;

        }

    }
